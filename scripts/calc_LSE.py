import matplotlib.pyplot as plt
import glob
import re
import numpy
import pandas as pd
import numpy as np
import os
import MDAnalysis as MDA
import math
import sys
from simuAnalysis_calculation import read_config
from scipy.optimize import curve_fit


def distance_2dots (point1,point2):
    if point1.ndim == 2:
        dis = math.sqrt((point1[0,0]-point2[0,0])**2+(point1[0,1]-point2[:,1])**2+(point1[0,2]-point2[0,2])**2)
        return dis
    if point1.ndim == 1:
        dis = math.sqrt((point1[0]-point2[0])**2+(point1[1]-point2[1])**2+(point1[2]-point2[2])**2)
        return dis


def Rg_per_frame (atom_group):
    center = atom_group.center_of_mass()
    all_atom = atom_group
    radi_sum = 0
    for i in all_atom.positions:
        radi_sum+=distance_2dots(center,i)
    return radi_sum/len(all_atom)


def preCalcLSE(universe,peptide_length,outputdir,start_step,end_step):
    """
    Calculates the Rg of each polymer length between 3 to the maximum length of the sequence.
    It gets the mean of all possible sliced sequence out from the full sequence, for all time points.
    Those calculation are used to assists the Flory calculation of the exponent (Length Scaling Exponent).
    :param universe: Universe class, generated by MDAnalysis.
    :param peptide_length: Number of residues in the full sequence.
    :param outputdir: Directory + the file prefix.
    :param start_step: Frame number to start analysing. Do not receive the time in the simulation. (integer)
    :param end_step: Frame number to end analysing. Do not receive the time in the simulation. (integer)
    :return: numpy array with the mean (and STD) Rg of every possible sub sequence within the full sequence
    (over all time points), for each polymer length.
    """
    universe_CA = universe.select_atoms("name CA")
    N=peptide_length
    n_start = 3
    Rg_n_mean_STD = np.zeros((N-n_start+1,3))
    for n in range(n_start,N+1):
        Rg_collect_time = np.zeros((N-n+1, end_step-start_step))
        for step, t in zip(universe.trajectory[start_step:end_step], range(start_step, end_step+1)):
            Rg_collect = np.zeros(N-n+1)
            for i,j in zip(range(1,N-n+2),range(n,N+1)):
                Rg_collect[i-1] = Rg_per_frame(universe_CA.select_atoms("resid "+str(i)+"-"+str(j)))
            Rg_collect_time[:,(t-start_step)] =Rg_collect
        Rg_n_mean_STD[n-n_start,0]=n
        Rg_n_mean_STD[n-n_start,1]=np.average(Rg_collect_time.ravel()[np.flatnonzero(Rg_collect_time)])
        Rg_n_mean_STD[n-n_start,2]=np.std(Rg_collect_time.ravel()[np.flatnonzero(Rg_collect_time)])
        print("n = {n} out of {total_n} is done.".format(n=n,total_n=N))
    pd.DataFrame.to_csv(pd.DataFrame(Rg_n_mean_STD, columns=["n", "Rg", "STD"]),outputdir+"_LSE.csv")
    return Rg_n_mean_STD


def run_preCalcLSE(directory,outputdir,sequence_name,start_step=None,end_step=None):
    """
    Runs the function preCalcLSE for every XTC file in the given directory.
    :param directory: Location of all XTC files to be analyzed.
    :param outputdir: The location for the analized files to be saved in.
    :param sequence_name: Name of the sequence should be written the as in the configuration file.
    :param start_step: Frame number to start analysing. Do not receive the time in the simulation. (integer)
    :param end_step: Frame number to end analysing. Do not receive the time in the simulation. (integer)
    """
    os.makedirs(outputdir, exist_ok=True)
    peptide_length = int(read_config(directory)[sequence_name][1])
    all_xtc_files = glob.glob(directory + "/*.xtc")
    all_topo_files = glob.glob(directory + "/*.gro")
    if len(all_topo_files)==0:
        all_topo_files = glob.glob(directory + "/*.pdb")
    for i in range(len(all_xtc_files)):
        xtc_name = re.search(".*/([^/].*).xtc",all_xtc_files[i]).group(1)
        universe = MDA.Universe(all_topo_files[0], all_xtc_files[i])
        if start_step == None:
            start_step = 1
        if end_step == None:
            end_step = len(universe.trajectory)
        print("Analyzing:   "+all_xtc_files[i])
        preCalcLSE(universe,peptide_length,outputdir=outputdir+xtc_name,start_step=start_step,end_step=end_step)
    print("Success!!! All the XTC files have been analyzed, files Rg as a function of polymer length were saved.")

def func(x,b,a):
    """
    The formula which explains the Rg of a polimer based on its length.
    Fit this formula to the  calculate Flory exponent (Length Scaling Exponent).
    :param x: The polymer length
    :param b: The Length Scaling Exponent.
    :param a: A scaler.
    :return: The expected Rg for a given polymer length.
    """
    return a*(x**b)


def calc_Rsquared(x,y,parameters):
    """Calculate R squared of the fitted curve"""
    y_mean = np.mean(y)
    total_sum_of_squares = np.sum((y-y_mean)**2)
    residuals_sum_of_squares = np.sum((y-func(x,*parameters))**2)
    Rsquared = 1-(residuals_sum_of_squares/total_sum_of_squares)
    return Rsquared


def fit_a_curve(train_data):
    """
    Fitting the curve the Flory function, to the observed data, to extract the LSE.
    :param train_data: A data frame with all samples as columns, polymer length as rows, and mean Rg as values.
    :return: The fitted parameters, STD, and R squared.
    """
    polymer_length = train_data["n"]
    Rg = train_data["Rg"]
    STD = train_data["STD"]
    parameters, pcov = curve_fit(func, polymer_length, Rg, sigma=STD)
    perr = (np.sqrt(np.diag(pcov)))
    Rsquared_train = calc_Rsquared(polymer_length,Rg,parameters)
    return parameters,perr,Rsquared_train


def split_data(directory):
    """Divides the data to training and testing sets"""
    all_LSE_files = glob.glob(directory + "*_LSE.csv")
    train_files = all_LSE_files[:-1]
    test_data = pd.read_csv(all_LSE_files[-1])
    train_data = pd.DataFrame()
    for file in train_files:
        Rg_overPolymerLengths = pd.read_csv(file)
        train_data = pd.concat([train_data, Rg_overPolymerLengths], axis=0, ignore_index=True)
    return train_data,test_data


def plot_LSE(directory,seqName,outputdir):
    """Plots the observed values of Rg over polymer lengths, and the fitted curve,
    along with the fitted parameters, and the confidence measurments (STD and R-squared)"""
    train_data, test_data = split_data(directory)
    parameters, perr, Rsquared_train = fit_a_curve(train_data)
    polymer_length = test_data["n"]
    Rg = test_data["Rg"]
    STD = test_data["STD"]
    fig, ax1 = plt.subplots(1, 1)
    ax1.plot(polymer_length, Rg, color="blue", label="Rg for polymer length")
    ax1.fill_between(polymer_length, Rg - STD, Rg + STD, color="blue", alpha=0.2)
    y_expected = func(polymer_length, *parameters)
    Rsquared_test = calc_Rsquared(polymer_length, Rg, parameters)
    R_train ="R^2(train): "+str(round(Rsquared_train,2))
    R_test ="R^2(test): "+str(round(Rsquared_test,2))
    a = "a: "+str(round(parameters[1],2))+"  STD: "+str(round(perr[1],3))
    b = "b: "+str(round(parameters[0],2))+"  STD: "+str(round(perr[0],3))
    ax1.plot(polymer_length,y_expected,color="red",label= "fitted function\n"+a+"\n"+b+"\n"+R_train+"\n"+R_test)
    ax1.set_title("Rg as a function of polymer length, with the best fiiting curve")
    ax1.legend()
    ax1.set_ylabel("Rg ($\AA$")
    ax1.set_xlabel("polymer length")
    plt.legend()
    plt.savefig(outputdir+"/LSE_"+seqName+".png")
    print("Success!!! Plot has been saved: Rg as a function of polymer length, with the best fiiting curve.")