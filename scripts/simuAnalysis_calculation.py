import os
import re
import MDAnalysis as MDA
import numpy as np
import math
import glob
import pandas as pd
import subprocess


def find_config_file(directory):
    """
    Iterate over all sub-directories in the main dir, and finds the configuration file,
    which includes the sequences names, and the positions in the sequence of the residues to be measured by distance.
    (called by read_config)
    :param directory: main directory path
    :return: The path to the config file.
    """
    directories_to_iter = [directory+"/"]
    while directories_to_iter:
        dir = directories_to_iter.pop()
        if glob.glob(dir+"*.config"):
            return glob.glob(dir+"*.config")[0]
        else:
            for subdir in [x for x in os.walk(dir)][0][1]:
                directories_to_iter.append(dir + subdir + "/")
    exit("No configuration file was found")


def read_config(directory):
    """
    Finds and reads the configuration file, which includes the sequences names,
    the positions in the sequence of the residues to be measured by distance,
    and the length scaling exponent (if FRET measurement is requested).
    All to be seperated by comma only.
    Example: sequence_name1,int,int,int
             sequence_name2,int,int,int
             ...
    (Calling find_config_file to first find the file)
    :param directory: main directory path
    :return: A dictionary, with the sequence name as a key, and the positions in a tuple as value.
    """
    config_file = open(find_config_file(directory)).read()
    rows_config = config_file.split("\n")
    configuration = {}
    for r in rows_config[:-1]:
        elements = r.split(",")
        configuration[elements[0]] = [x for x in elements[1:]]
    return configuration


def distance_2dots (point1,point2):
    """
    Calculates the distance between two points in 3D space.
    :param point1: X,Y,Z coordinates for the first point (Numpy array)
    :param point2: X,Y,Z coordinates for the second point (Numpy array)
    :return: Distance between two points (Float).
    """
    if point1.ndim == 2:
        dis = math.sqrt((point1[0,0]-point2[0,0])**2+(point1[0,1]-point2[:,1])**2+(point1[0,2]-point2[0,2])**2)
        return dis
    if point1.ndim == 1:
        dis = math.sqrt((point1[0]-point2[0])**2+(point1[1]-point2[1])**2+(point1[2]-point2[2])**2)
        return dis


def Rg_per_frame (universe):
    """
    Calculates the Rg of the protein for the exact time frame. The function includes only C alpha atoms,
    for improved calculation efficiency.
    :param universe: Universe class, generated by MDAnalysis
    :return: Rg from the center of mass.
    """
    center = universe.select_atoms("protein").center_of_mass()
    all_atom = universe.select_atoms("name CA")
    radi_sum = 0
    for i in all_atom.positions:
        radi_sum+=distance_2dots(center,i)
    return radi_sum/len(all_atom)


def Rg_t_lapse (universe,start_step=None,end_step=None):
    """
    Calculates Rg for a simulation time period.The function includes only C alpha atoms,
    for improved calculation efficiency. If time period id not specified, than the entire simulation will be analyzed.
    :param universe: Universe class, generated by MDAnalysis
    :param start_step: Frame number to start analysing. Do not receive the time in the simulation. (integer)
    :param end_step: Frame number to end analysing. Do not receive the time in the simulation. (integer)
    :return: numpy.array with time steps of the simulation, and Rg for each step(simulation length,2).
    """
    simulation_trajectory = universe.trajectory[start_step:end_step]
    data = np.zeros((len(simulation_trajectory),2))
    for steps,time in zip(simulation_trajectory,range(len(simulation_trajectory))):
        data[time,0] = universe.trajectory.time
        data[time,1] = Rg_per_frame(universe)
    return data


def resi_distance (resi1, resi2,universe=None,start_step=None,end_step=None):
    """
    Calculates the distance between two residues for a simulation time period.The function includes only C alpha atoms,
    for improved calculation efficiency. If time period id not specified, than the entire simulation will be analyzed.
    :param resi1: Location of the first residue on the chain (integer)
    :param resi2: Location of the second residue on the chain (integer)
    :param universe: Universe class, generated by MDAnalysis.
    :param start_step: Frame number to start analysing. Do not receive the time in the simulation. (integer)
    :param end_step: Frame number to end analysing. Do not receive the time in the simulation. (integer)
    :return: numpy.array with time steps of the simulation, and the distance between two of interest for each step(simulation length,2).
    """
    residue_1 = universe.select_atoms("resid "+str(resi1)+"-"+str(resi1) +" and name CA")
    residue_2 = universe.select_atoms("resid "+str(resi2)+"-"+str(resi2) +" and name CA")
    simulation_trajectory = universe.trajectory[start_step:end_step]
    data = np.zeros((len(simulation_trajectory),2))
    for steps,time in zip(simulation_trajectory,range(len(simulation_trajectory))):
        data[time,0] = universe.trajectory.time
        data[time,1] = distance_2dots(residue_1.positions,residue_2.positions)
    return data


def pdbAnalysis (input_directory,resi1,resi2,start_step=None,end_step=None):
    """
    Analyzes the RG and residues distances for all the .pbd files (from coarse grain simulations) in the given directory.
    :param input_directory:
    :param resi1: Residue index on the peptide, for calculating distance with resi2. (index start from 1 not 0) (integer)
    :param resi2:
    :param start_step: Frame number to start analysing. Do not receive the time in the simulation. (integer)
    :param end_step: Frame number to end analysing. Do not receive the time in the simulation. (integer)
    :return: Data Frame with each calculation (Rg and residue distance) for each repeat as a column.
    """
    all_pdbs_files = glob.glob(input_directory+"/*.pdb")
    all_data = pd.DataFrame()
    first = True
    for i in range(len(all_pdbs_files)):
        universe = MDA.Universe(all_pdbs_files[i])
        if first:
            all_data = pd.DataFrame(Rg_t_lapse(universe, start_step, end_step),columns=['time',"Rg_repeat_" + str(i+1)])
            all_data["resi_distance_repeat_1"] = resi_distance(resi1, resi2, universe, start_step, end_step)[:,1]
            first = False
        else:
            all_data["resi_distance_repeat_" + str(i+1)] = resi_distance(resi1, resi2, universe, start_step, end_step)[:,1]
            all_data["Rg_repeat_" + str(i+1)] = Rg_t_lapse(universe, start_step, end_step)[:,1]
    return all_data


def xtcAnalysis(directory, resi1, resi2, start_step=None, end_step=None):
    """
    Analyzes the RG and residues distances for all the .xtc files (from atomistic simulations) in the given directory.
    Directory must include a topology file (either .gro or .pdb)
    :param directory:
    :param resi1: Residue index on the peptide, for calculating distance with resi2. (index start from 1 not 0) (integer)
    :param resi2:
    :param start_step: Frame number to start analysing. Do not receive the time in the simulation. (integer)
    :param end_step: Frame number to end analysing. Do not receive the time in the simulation. (integer)
    :return: Data Frame with each calculation (Rg and residue distance) for each repeat as a column.
    """
    all_xtc_files = glob.glob(directory + "/*.xtc")
    all_topo_files = glob.glob(directory + "/*.gro")
    if len(all_topo_files) == 0:
        all_topo_files = glob.glob(directory + "/*.pdb")
    resi1, resi2 = (int(resi1+1), int(resi2+1))
    all_data = pd.DataFrame()
    first = True
    for i in range(len(all_xtc_files)):
        print("XTCAnalysis on:", all_xtc_files[i])
        universe = MDA.Universe(all_topo_files[0],all_xtc_files[i])
        if first:
            all_data = pd.DataFrame(Rg_t_lapse(universe, start_step, end_step),
                                    columns=['time', "Rg_repeat_" + str(i + 1)])
            all_data["resi_distance_repeat_1"] = resi_distance(resi1, resi2, universe, start_step, end_step)[:, 1]
            first = False
        else:
            all_data["resi_distance_repeat_" + str(i + 1)] = resi_distance(resi1, resi2, universe, start_step,
                                                                           end_step)[:, 1]
            all_data["Rg_repeat_" + str(i + 1)] = Rg_t_lapse(universe, start_step, end_step)[:, 1]
    return all_data


def merge_continue_and_start(directory_start,directory_continue,output_directory,resi1, resi2,end_time, start_step=None, end_step=None):
    segment = re.search(r".*(seg[ABC]).*", directory_start).group(1)
    start_data = xtcAnalysis(directory_start,resi1, resi2, start_step)
    continue_data = xtcAnalysis(directory_continue,resi1, resi2, start_step=0,end_step=end_step)
    continue_data["time"]= np.array(continue_data["time"])+end_time
    complete_data = pd.concat([start_data,continue_data],ignore_index=True)
    pd.DataFrame.to_csv(complete_data, output_directory+"/"+segment + ".csv")


def save_xtcAnalysis(input_directory,sequence_name,calc_fret = False,outputdir=None,start_step=None,end_step=None):
    """
    Takes a directory with preprocessed xtc files (pbc - noJump, and skipped frames),
    and Analyzes the RG and residues distances for all by applying xtcAnalysis.
    :param input_directory:
    :param sequence_name: Name of the sequence should be written the as in the configuration file.
    :param outputdir: If not given, it directs the results into a new dir within the input directory.
    :param start_step: Frame number to start analysing. Do not receive the time in the simulation. (integer)
    :param end_step: Frame number to end analysing. Do not receive the time in the simulation. (integer)
    :return: CSV file with the Rg and residue distance calculations for each repeat as a column.
    """
    sequenses_configuration = read_config(input_directory)
    resi1, resi2 = [int(x) for x in sequenses_configuration[sequence_name][0:2]]
    if outputdir != None:
        output_directory = outputdir+"/"
    else: output_directory = input_directory+"/AnalyzedData/"
    os.makedirs(output_directory, exist_ok=True)
    data = xtcAnalysis(input_directory,resi1,resi2,start_step,end_step)
    pd.DataFrame.to_csv(data, output_directory +sequence_name+ ".csv")
    print("Success!!! All the XTC files have been analyzed, files were saved in CSV format.")
    if calc_fret:
        iter_calc_FRET(output_directory + sequence_name + ".csv",sequenses_configuration)




def iterPDBAnalysis(directory,output_dir,start_step=None,end_step=None):
    """
    Iterates over a tree directory, no matter its depth size, and applies PDBAnalysis on sub-directories with
    .pdb files in it. A configuration file should be included some where in the input directory.
    :param directory: Any tree directory with coarse-grain output as leaf directories. Must not include dirs without
    coarse-grain output at its end.
    :param start_step: Frame number to start analysing. Do not receive the time in the simulation. (integer)
    :param end_step: Frame number to end analysing. Do not receive the time in the simulation. (integer)
    :return: A new exact tree directory, with the PDBAnalysis output as .csv files, in the leaf directories.
    The directory is saved in a default dir ('set_output_directory')
    """
    sequenses_configuration = read_config(directory)
    directory_without_main = re.search("(.*/).*/",directory).group(1)
    directories_toiter = [directory]
    while directories_toiter:
        dir = directories_toiter.pop()
        if "output" in [x for x in os.walk(dir)][0][1]:
            print("PDBAnalysis on:",dir+"output/traj/")
            seq_name = re.search(".*/([^/]*)/", dir).group(1)
            down_tree = re.search(directory_without_main+"(.*)",dir).group(1)
            data = pdbAnalysis(dir + "output/Traj/", sequenses_configuration[seq_name][0], sequenses_configuration[seq_name][1], start_step, end_step)
            os.makedirs(output_dir+down_tree,exist_ok=True)
            pd.DataFrame.to_csv(data,output_dir+down_tree+"file.csv")
        else:
            for subdir in [x for x in os.walk(dir)][0][1]:
                directories_toiter.append(dir+subdir+"/")
    print("Success!!! All the PDB files have been analyzed, files were saved.")

def zip2pdb(directory):
    """
    Iterates over a tree directory, no matter its depth size, unzips every output zip file, and converts .dat file
    .pbd file. Converting .dat to .pdb every X frames, specified by 'skip_frame'.
    :param directory: Any tree directory with coarse-grain output as leaf directories. Must not include dirs without
    coarse-grain output at its end.
    :return:
    """
    unzip_command = "bunzip2 *"
    directories_toiter = [directory]
    skip_frame = "2"        # number, which specifies how many frames to skip when converting to pdb
    while directories_toiter:
        dir = directories_toiter.pop()
        if "output" in [x for x in os.walk(dir)][0][1]:
            wd = dir+"output/Traj/"
            print("zip2pdb on:", wd)
            subprocess.Popen(unzip_command, cwd=wd, shell=True).wait()
            for file in glob.glob(dir+"output/Traj/*.dat"):
                subprocess.Popen([os.path.dirname(__file__)+"/TrajToPDB.pl",file,skip_frame]).wait()
        else:
            for subdir in [x for x in os.walk(dir)][0][1]:
                directories_toiter.append(dir+subdir+"/")


def calc_FRET(data,sequence_name,sequenses_configuration):
    """
    Calculates the estimated FRET measurement for the atomistic simulation.
    :param data: The input should be an array of distances between the two query residues.
    :param sequence_name: Name of the sequence should be written the as in the configuration file.
    :param sequenses_configuration: TXT file which includes the sequence name, length of sequence as position 2,
    and the length scaling exponent.
    :return: An array with the FRET estimated measurements.
    """
    if len(sequenses_configuration[sequence_name])<3:
        exit("Error: Can't calculate FRET, since 'Length Scaling Exponent' is missing in the configuration file."+"\n"+
             "The LSE can be calculated by simuAnalysis, with the attribute '-runMode calcLSE' "+"\n"+
             "(Exponent should be infered from the exported plot, and written in the configuration file")
    N = int(sequenses_configuration[sequence_name][1])
    exponent = float(sequenses_configuration[sequence_name][2])
    marker_length = 9 # the marker length might vary by experiment method
    scaler = (N/(N+marker_length))**exponent
    scaled_toinclude_markers = data*scaler
    R_zero = 54
    FRET_measures= (R_zero**6)/(scaled_toinclude_markers**6+R_zero**6)
    return FRET_measures


def iter_calc_FRET(csv_file,sequenses_configuration):
    """
    Calculates the estimated FRET measurement for the atomistic simulation, for each repeat in the data.
    :param csv_file: An xtcAnalysis output, with the residues distances of each repeat.
    :param sequenses_configuration: TXT file which includes the sequence name, length of sequence as position 2,
    and the length scaling exponent.
    :return: The same CSV file which was given as input, with extra columns of FRET measurements for each repeat.
    """
    sequence_name = re.search(".*/([^/]*).csv",csv_file).group(1)
    df = pd.read_csv(csv_file)
    for col in df.columns:
        if "resi_distance" in col:
            reapeat_num = re.search(".*(\d).*",col).group(1)
            df["smFRET_"+str(reapeat_num)] = calc_FRET(df[col],sequence_name,sequenses_configuration)
    pd.DataFrame.to_csv(df, csv_file)
    print("Success!!! All the CSV files have been analyzed, and FRET measurements were added.")
